{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Django pattern library \u00b6 UI pattern libraries for Django templates Features \u00b6 The django-pattern-library package automates the maintenance of UI pattern libraries or styleguides for Django projects, and allows developers to experiment with Django templates without having to create Django views and models. Create reusable patterns by creating Django templates files as usual. All patterns automatically show up in the pattern library\u2019s interface. Define data as YAML files for the templates to render with the relevant Django context. Override Django templates tags as needed to mock the template\u2019s dependencies. Document your patterns with Markdown. Here is a screenshot of the pattern library in action: Why you need this \u00b6 Pattern libraries will change your workflow for the better: They help separate concerns, both in code, and between members of a development team. If needed, they make it possible for UI development to happen before models and views are created. They encourage code reuse \u2013 defining independent UI components, that can be reused across apps, or ported to other projects. It makes it much simpler to test UI components \u2013 no need to figure out where they\u2019re used across a site or app. Online demo \u00b6 The pattern library is dependent on Django for rendering \u2013 but also supports exporting as a static site if needed. Try out our online demo: For a component, accordion.html For a page-level template, person_page.html Why this exists \u00b6 We want to make it possible for developers to maintain large pattern libraries with minimal fuss \u2013 no copy-pasting of templates between a static library and the \u201cproduction\u201d templates. There are a lot of alternative solutions for building pattern libraries, or to have UI development playgrounds . At Torchbox we mainly use Django and Wagtail, and we found it hard to maintain large libraries with those tools that have no awareness of Django Templates. This is our attempt to solve this issue \u2013 Pattern Lab goes Django! To learn more about how this package can be used, have a look at our talk: Reusable UI components: A journey from React to Wagtail","title":"Home"},{"location":"#django-pattern-library","text":"UI pattern libraries for Django templates","title":"Django pattern library"},{"location":"#features","text":"The django-pattern-library package automates the maintenance of UI pattern libraries or styleguides for Django projects, and allows developers to experiment with Django templates without having to create Django views and models. Create reusable patterns by creating Django templates files as usual. All patterns automatically show up in the pattern library\u2019s interface. Define data as YAML files for the templates to render with the relevant Django context. Override Django templates tags as needed to mock the template\u2019s dependencies. Document your patterns with Markdown. Here is a screenshot of the pattern library in action:","title":"Features"},{"location":"#why-you-need-this","text":"Pattern libraries will change your workflow for the better: They help separate concerns, both in code, and between members of a development team. If needed, they make it possible for UI development to happen before models and views are created. They encourage code reuse \u2013 defining independent UI components, that can be reused across apps, or ported to other projects. It makes it much simpler to test UI components \u2013 no need to figure out where they\u2019re used across a site or app.","title":"Why you need this"},{"location":"#online-demo","text":"The pattern library is dependent on Django for rendering \u2013 but also supports exporting as a static site if needed. Try out our online demo: For a component, accordion.html For a page-level template, person_page.html","title":"Online demo"},{"location":"#why-this-exists","text":"We want to make it possible for developers to maintain large pattern libraries with minimal fuss \u2013 no copy-pasting of templates between a static library and the \u201cproduction\u201d templates. There are a lot of alternative solutions for building pattern libraries, or to have UI development playgrounds . At Torchbox we mainly use Django and Wagtail, and we found it hard to maintain large libraries with those tools that have no awareness of Django Templates. This is our attempt to solve this issue \u2013 Pattern Lab goes Django! To learn more about how this package can be used, have a look at our talk: Reusable UI components: A journey from React to Wagtail","title":"Why this exists"},{"location":"getting-started/","text":"Getting started \u00b6 If you just want to see django-pattern-library up and running, have a look at our online demo . Installation \u00b6 django-pattern-library is available on PyPI . First install it in your Django project: # With pip, pip install django-pattern-library # Alternatively, with Poetry, poetry add --dev django-pattern-library Compatibility \u00b6 We support: Django 2.2.x, 3.0.x, 3.1.x, 3.2.x, 4.0.x (experimental) Python 3.6, 3.7, 3.8, 3.9 Django Templates only, no Jinja support Configuration \u00b6 Django settings \u00b6 In your Django settings file, add pattern_library to INSTALLED_APPS : INSTALLED_APPS = [ # ... \"pattern_library\" , # ... ] Also add pattern_library.loader_tags to OPTIONS[\"builtins\"] into the TEMPLATES setting: TEMPLATES = [ { \"BACKEND\" : \"django.template.backends.django.DjangoTemplates\" , \"DIRS\" : [], \"APP_DIRS\" : True , \"OPTIONS\" : { \"context_processors\" : [ \"django.template.context_processors.debug\" , \"django.template.context_processors.request\" , \"django.contrib.auth.context_processors.auth\" , \"django.contrib.messages.context_processors.messages\" , ], \"builtins\" : [ \"pattern_library.loader_tags\" ], }, }, ] Pattern library settings \u00b6 Still in Django settings, set the PATTERN_LIBRARY setting. Here is an example showing the defaults: PATTERN_LIBRARY = { # Groups of templates for the pattern library navigation. The keys # are the group titles and the values are lists of template name prefixes that will # be searched to populate the groups. \"SECTIONS\" : ( ( \"components\" , [ \"patterns/components\" ]), ( \"pages\" , [ \"patterns/pages\" ]), ), # Configure which files to detect as templates. \"TEMPLATE_SUFFIX\" : \".html\" , # Set which template components should be rendered inside of, # so they may use page-level component dependencies like CSS. \"PATTERN_BASE_TEMPLATE_NAME\" : \"patterns/base.html\" , # Any template in BASE_TEMPLATE_NAMES or any template that extends a template in # BASE_TEMPLATE_NAMES is a \"page\" and will be rendered as-is without being wrapped. \"BASE_TEMPLATE_NAMES\" : [ \"patterns/base_page.html\" ], } Note the templates in your PATTERN_LIBRARY settings must be available to template loaders . URLs \u00b6 Include pattern_library.urls in your urlpatterns . Here is an example urls.py : from django.apps import apps from django.urls import include , path urlpatterns = [ # \u2026 Your URLs ] if apps . is_installed ( \"pattern_library\" ): urlpatterns += [ path ( \"pattern-library/\" , include ( \"pattern_library.urls\" )), ] Security This package isn\u2019t intended for production usage, and hasn\u2019t received extensive security scrutiny. It is highly recommended to only enable this package in testing environments, for a restricted, trusted audience. One way to do this is to only expose its URLs if apps.is_installed(\"pattern_library\") , as demonstrated above, and only have the app installed in environment-specific settings. Alright, now that we got this far, we can navigate to http://localhost:8000/pattern-library/ to see our pattern library! But if we tried to do this now, we would likely get a PatternLibraryEmpty error \u2013 this is expected, as we haven\u2019t added any patterns yet. Now let\u2019s look at adding our first template! First pattern \u00b6 Now we\u2019ve done all of the configuration \u2013 let\u2019s create a UI component. We\u2019ll use quote-block as an example, and place it at patterns/components/quote_block/quote_block.html inside one of our Django apps: <blockquote class= \"quote-block block--spacing\" > <div class= \"quote-block__text\" > <p class= \"quote-block__quote\" > {{ quote }} </p> {% if attribution %} <p class= \"quote-block__attribution\" > {{ attribution }} </p> {% endif %} </div> </blockquote> Base template \u00b6 We additionally need to customize a base template, so the standalone component can be rendered within a page with CSS. This is what the PATTERN_BASE_TEMPLATE_NAME setting is for. As a separate template in patterns/base.html : <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < title > My Base </ title > </ head > < body > {% block content %} {# pattern_library_rendered_pattern is where the pattern library will inject the rendered pattern. #} {{ pattern_library_rendered_pattern }} {% endblock %} </ body > </ html > quote_block should now appear in the pattern library UI menu! But the template doesn\u2019t display anything \u2013 we additionally need to provide it with test data. Component data \u00b6 We can provide context and tags overrides for our new component by creating a quote_block.yaml YAML file alongside the HTML, at patterns/components/quote_block/quote_block.yaml in our example. context : quote : What is love? attribution : Haddaway We could also provide it with a custom name: name : Quote Block context : quote : What is love? attribution : Haddaway And that\u2019s it! Our quote_block should finally appear in the pattern library, along with its rendering with this mock data.","title":"Getting started"},{"location":"getting-started/#getting-started","text":"If you just want to see django-pattern-library up and running, have a look at our online demo .","title":"Getting started"},{"location":"getting-started/#installation","text":"django-pattern-library is available on PyPI . First install it in your Django project: # With pip, pip install django-pattern-library # Alternatively, with Poetry, poetry add --dev django-pattern-library","title":"Installation"},{"location":"getting-started/#compatibility","text":"We support: Django 2.2.x, 3.0.x, 3.1.x, 3.2.x, 4.0.x (experimental) Python 3.6, 3.7, 3.8, 3.9 Django Templates only, no Jinja support","title":"Compatibility"},{"location":"getting-started/#configuration","text":"","title":"Configuration"},{"location":"getting-started/#django-settings","text":"In your Django settings file, add pattern_library to INSTALLED_APPS : INSTALLED_APPS = [ # ... \"pattern_library\" , # ... ] Also add pattern_library.loader_tags to OPTIONS[\"builtins\"] into the TEMPLATES setting: TEMPLATES = [ { \"BACKEND\" : \"django.template.backends.django.DjangoTemplates\" , \"DIRS\" : [], \"APP_DIRS\" : True , \"OPTIONS\" : { \"context_processors\" : [ \"django.template.context_processors.debug\" , \"django.template.context_processors.request\" , \"django.contrib.auth.context_processors.auth\" , \"django.contrib.messages.context_processors.messages\" , ], \"builtins\" : [ \"pattern_library.loader_tags\" ], }, }, ]","title":"Django settings"},{"location":"getting-started/#pattern-library-settings","text":"Still in Django settings, set the PATTERN_LIBRARY setting. Here is an example showing the defaults: PATTERN_LIBRARY = { # Groups of templates for the pattern library navigation. The keys # are the group titles and the values are lists of template name prefixes that will # be searched to populate the groups. \"SECTIONS\" : ( ( \"components\" , [ \"patterns/components\" ]), ( \"pages\" , [ \"patterns/pages\" ]), ), # Configure which files to detect as templates. \"TEMPLATE_SUFFIX\" : \".html\" , # Set which template components should be rendered inside of, # so they may use page-level component dependencies like CSS. \"PATTERN_BASE_TEMPLATE_NAME\" : \"patterns/base.html\" , # Any template in BASE_TEMPLATE_NAMES or any template that extends a template in # BASE_TEMPLATE_NAMES is a \"page\" and will be rendered as-is without being wrapped. \"BASE_TEMPLATE_NAMES\" : [ \"patterns/base_page.html\" ], } Note the templates in your PATTERN_LIBRARY settings must be available to template loaders .","title":"Pattern library settings"},{"location":"getting-started/#urls","text":"Include pattern_library.urls in your urlpatterns . Here is an example urls.py : from django.apps import apps from django.urls import include , path urlpatterns = [ # \u2026 Your URLs ] if apps . is_installed ( \"pattern_library\" ): urlpatterns += [ path ( \"pattern-library/\" , include ( \"pattern_library.urls\" )), ] Security This package isn\u2019t intended for production usage, and hasn\u2019t received extensive security scrutiny. It is highly recommended to only enable this package in testing environments, for a restricted, trusted audience. One way to do this is to only expose its URLs if apps.is_installed(\"pattern_library\") , as demonstrated above, and only have the app installed in environment-specific settings. Alright, now that we got this far, we can navigate to http://localhost:8000/pattern-library/ to see our pattern library! But if we tried to do this now, we would likely get a PatternLibraryEmpty error \u2013 this is expected, as we haven\u2019t added any patterns yet. Now let\u2019s look at adding our first template!","title":"URLs"},{"location":"getting-started/#first-pattern","text":"Now we\u2019ve done all of the configuration \u2013 let\u2019s create a UI component. We\u2019ll use quote-block as an example, and place it at patterns/components/quote_block/quote_block.html inside one of our Django apps: <blockquote class= \"quote-block block--spacing\" > <div class= \"quote-block__text\" > <p class= \"quote-block__quote\" > {{ quote }} </p> {% if attribution %} <p class= \"quote-block__attribution\" > {{ attribution }} </p> {% endif %} </div> </blockquote>","title":"First pattern"},{"location":"getting-started/#base-template","text":"We additionally need to customize a base template, so the standalone component can be rendered within a page with CSS. This is what the PATTERN_BASE_TEMPLATE_NAME setting is for. As a separate template in patterns/base.html : <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < title > My Base </ title > </ head > < body > {% block content %} {# pattern_library_rendered_pattern is where the pattern library will inject the rendered pattern. #} {{ pattern_library_rendered_pattern }} {% endblock %} </ body > </ html > quote_block should now appear in the pattern library UI menu! But the template doesn\u2019t display anything \u2013 we additionally need to provide it with test data.","title":"Base template"},{"location":"getting-started/#component-data","text":"We can provide context and tags overrides for our new component by creating a quote_block.yaml YAML file alongside the HTML, at patterns/components/quote_block/quote_block.yaml in our example. context : quote : What is love? attribution : Haddaway We could also provide it with a custom name: name : Quote Block context : quote : What is love? attribution : Haddaway And that\u2019s it! Our quote_block should finally appear in the pattern library, along with its rendering with this mock data.","title":"Component data"},{"location":"guides/automated-tests/","text":"Automated tests \u00b6 Although pattern libraries often start as tools for manual tests during development, they can also be useful for automated UI testing. There are a few benefits to doing UI tests with a pattern library: Test the components in isolation. When tests fail, you will know exactly which component has issues, rather than having to inspect whole pages to understand what might have changed. Test the components with mock data. One of the issues with UI tests is to have test data for your UIs to render \u2013 you can reuse the pattern library data for this purpose (althoug there are limitations ). Setting up automated UI tests \u00b6 There are two ways to set up automated tests: by accessing templates as they are rendered by the pattern library directly with Django, or by pre-rendering the templates with render_patterns command and then using this static export to make automated tests. Served by Django \u00b6 Make sure your Django server is up and running, and you can then point your tests directly at the pattern library\u2019s iframe URLs, for example: http://localhost:8000/pattern-library/render-pattern/patterns/molecules/accordion/accordion.html . Note this will always render your templates within the base template ( PATTERN_BASE_TEMPLATE_NAME ), which may or may not be appropriate for your tests. With render_patterns \u00b6 The render_patterns command command can be used to export all your templates, so you can do bulk checks on them all. For example, testing all templates use valid HTML with the v.Nu HTML5 validator : ./manage.py render_patterns --wrap-fragments vnu dpl-rendered-patterns/**/*.html One of the advantages of render_patterns is the ability for you to test the patterns without wrapping fragments in the base template, should this be more appropriate for your tests. Visual regression testing \u00b6 Pattern libraries are a natural fit for automated visual regression tests. Here is an example BackstopJS configuration file: { \"viewports\" : [ { \"label\" : \"tablet\" , \"width\" : 1024 , \"height\" : 768 } ], \"scenarios\" : [ { \"label\" : \"accordion.html\" , \"url\" : \"https://torchbox.github.io/django-pattern-library/dpl-rendered-patterns/molecules/accordion/accordion.html\" }, { \"label\" : \"person_page.html\" , \"url\" : \"https://torchbox.github.io/django-pattern-library/dpl-rendered-patterns/pages/people/person_page.html\" } ], \"paths\" : { \"bitmaps_reference\" : \"backstop_data/bitmaps_reference\" , \"bitmaps_test\" : \"backstop_data/bitmaps_test\" , \"engine_scripts\" : \"backstop_data/engine_scripts\" , \"html_report\" : \"backstop_data/html_report\" , \"ci_report\" : \"backstop_data/ci_report\" }, \"engine\" : \"puppeteer\" } Try this out by saving the file as backstop.json , then: npm install -g backstopjs backstop test Accessibility testing \u00b6 Here as well, pattern libraries are a natural fit, due to them providing the test data, and making it possible to test components in isolation. Have a look at Pa11y or Lighthouse CI to get started. Here is an example Pa11y configuration: module . exports = { defaults : { standard : \"WCAG2AAA\" , runners : [ \"axe\" ], }, urls : [ \"https://torchbox.github.io/django-pattern-library/dpl-rendered-patterns/molecules/accordion/accordion.html\" , \"https://torchbox.github.io/django-pattern-library/dpl-rendered-patterns/pages/people/person_page.html\" , ], }; Try this out by saving the file as pa11y.config.js , then: npm install -g pa11y-ci pa11y-ci --config pa11y.config.js","title":"Automated tests"},{"location":"guides/automated-tests/#automated-tests","text":"Although pattern libraries often start as tools for manual tests during development, they can also be useful for automated UI testing. There are a few benefits to doing UI tests with a pattern library: Test the components in isolation. When tests fail, you will know exactly which component has issues, rather than having to inspect whole pages to understand what might have changed. Test the components with mock data. One of the issues with UI tests is to have test data for your UIs to render \u2013 you can reuse the pattern library data for this purpose (althoug there are limitations ).","title":"Automated tests"},{"location":"guides/automated-tests/#setting-up-automated-ui-tests","text":"There are two ways to set up automated tests: by accessing templates as they are rendered by the pattern library directly with Django, or by pre-rendering the templates with render_patterns command and then using this static export to make automated tests.","title":"Setting up automated UI tests"},{"location":"guides/automated-tests/#served-by-django","text":"Make sure your Django server is up and running, and you can then point your tests directly at the pattern library\u2019s iframe URLs, for example: http://localhost:8000/pattern-library/render-pattern/patterns/molecules/accordion/accordion.html . Note this will always render your templates within the base template ( PATTERN_BASE_TEMPLATE_NAME ), which may or may not be appropriate for your tests.","title":"Served by Django"},{"location":"guides/automated-tests/#with-render_patterns","text":"The render_patterns command command can be used to export all your templates, so you can do bulk checks on them all. For example, testing all templates use valid HTML with the v.Nu HTML5 validator : ./manage.py render_patterns --wrap-fragments vnu dpl-rendered-patterns/**/*.html One of the advantages of render_patterns is the ability for you to test the patterns without wrapping fragments in the base template, should this be more appropriate for your tests.","title":"With render_patterns"},{"location":"guides/automated-tests/#visual-regression-testing","text":"Pattern libraries are a natural fit for automated visual regression tests. Here is an example BackstopJS configuration file: { \"viewports\" : [ { \"label\" : \"tablet\" , \"width\" : 1024 , \"height\" : 768 } ], \"scenarios\" : [ { \"label\" : \"accordion.html\" , \"url\" : \"https://torchbox.github.io/django-pattern-library/dpl-rendered-patterns/molecules/accordion/accordion.html\" }, { \"label\" : \"person_page.html\" , \"url\" : \"https://torchbox.github.io/django-pattern-library/dpl-rendered-patterns/pages/people/person_page.html\" } ], \"paths\" : { \"bitmaps_reference\" : \"backstop_data/bitmaps_reference\" , \"bitmaps_test\" : \"backstop_data/bitmaps_test\" , \"engine_scripts\" : \"backstop_data/engine_scripts\" , \"html_report\" : \"backstop_data/html_report\" , \"ci_report\" : \"backstop_data/ci_report\" }, \"engine\" : \"puppeteer\" } Try this out by saving the file as backstop.json , then: npm install -g backstopjs backstop test","title":"Visual regression testing"},{"location":"guides/automated-tests/#accessibility-testing","text":"Here as well, pattern libraries are a natural fit, due to them providing the test data, and making it possible to test components in isolation. Have a look at Pa11y or Lighthouse CI to get started. Here is an example Pa11y configuration: module . exports = { defaults : { standard : \"WCAG2AAA\" , runners : [ \"axe\" ], }, urls : [ \"https://torchbox.github.io/django-pattern-library/dpl-rendered-patterns/molecules/accordion/accordion.html\" , \"https://torchbox.github.io/django-pattern-library/dpl-rendered-patterns/pages/people/person_page.html\" , ], }; Try this out by saving the file as pa11y.config.js , then: npm install -g pa11y-ci pa11y-ci --config pa11y.config.js","title":"Accessibility testing"},{"location":"guides/customizing-template-rendering/","text":"Customizing template rendering \u00b6 Customizing all patterns\u2019 surroundings \u00b6 All patterns that are not pages are rendered within a base page template. The pattern library will render patterns inside the content block, which you can tweak to change how patterns are displayed. You can for example add a theme wrapper around the components: {% block content %} {% if pattern_library_rendered_pattern %} <div class= \"pattern-library bg bg--light\" > {{ pattern_library_rendered_pattern }} </div> {% endif %} {% endblock %} pattern_library_rendered_pattern can also be used to do other modifications on the page for the pattern library only, for example adding an extra class to <body> : <body class=\" {% block body_class %}{% endblock %}{% if pattern_library_rendered_pattern %} pattern-library-template {% endif %} \"> Customizing a single pattern\u2019s rendering \u00b6 There is no API to customize a single pattern\u2019s rendering, but it can be done by using pattern-library-only templates. For example, with our quote_block.html component: <blockquote class=\"quote-block block--spacing\"> <div class=\"quote-block__text\"> <p class=\"quote-block__quote\"> {{ quote }} </p> {% if attribution %} <p class=\"quote-block__attribution\"> {{ attribution }} </p> {% endif %} </div> </blockquote> We could create another template next to it called quote_block_example.html , <div class=\"pattern-library bg bg--light\"> {% include \"patterns/components/quote_block/quote_block.html\" with attribution = attribution quote = quote %} </div> This is a fair amount of boilerplate, but neatly solves the problem per pattern.","title":"Customizing rendering"},{"location":"guides/customizing-template-rendering/#customizing-template-rendering","text":"","title":"Customizing template rendering"},{"location":"guides/customizing-template-rendering/#customizing-all-patterns-surroundings","text":"All patterns that are not pages are rendered within a base page template. The pattern library will render patterns inside the content block, which you can tweak to change how patterns are displayed. You can for example add a theme wrapper around the components: {% block content %} {% if pattern_library_rendered_pattern %} <div class= \"pattern-library bg bg--light\" > {{ pattern_library_rendered_pattern }} </div> {% endif %} {% endblock %} pattern_library_rendered_pattern can also be used to do other modifications on the page for the pattern library only, for example adding an extra class to <body> : <body class=\" {% block body_class %}{% endblock %}{% if pattern_library_rendered_pattern %} pattern-library-template {% endif %} \">","title":"Customizing all patterns\u2019 surroundings"},{"location":"guides/customizing-template-rendering/#customizing-a-single-patterns-rendering","text":"There is no API to customize a single pattern\u2019s rendering, but it can be done by using pattern-library-only templates. For example, with our quote_block.html component: <blockquote class=\"quote-block block--spacing\"> <div class=\"quote-block__text\"> <p class=\"quote-block__quote\"> {{ quote }} </p> {% if attribution %} <p class=\"quote-block__attribution\"> {{ attribution }} </p> {% endif %} </div> </blockquote> We could create another template next to it called quote_block_example.html , <div class=\"pattern-library bg bg--light\"> {% include \"patterns/components/quote_block/quote_block.html\" with attribution = attribution quote = quote %} </div> This is a fair amount of boilerplate, but neatly solves the problem per pattern.","title":"Customizing a single pattern\u2019s rendering"},{"location":"guides/defining-template-context/","text":"Defining template context \u00b6 To define fake context you need to create a YAML file alongside your template file. For example, for the template big_red_button.html you need to create a file called big_red_button.yaml . Let's imagine that your big_red_button.html template looks like this: <a href=\" {{ button_link }} \" class=\"button button--red\"> <span> {{ button_text }} </span> </a> The big_red_button.yaml can be something like this: context : button_link : https://example.com/ button_text : Example link In the same way you can provide context in more complex templates. Here is an example on how you can define fake context that pretends to be a QuerySet . Let's assume you have the following template: {% if my_objects.exists %} {{ items_title }} <ul> {% for obj in my_objects.all %} <li> <a href=\" {{ obj.link }} \"> {{ obj.title }} </a> </li> {% endfor %} </ul> {% endif %} You might define a YAML file similar to this to provide fake data: name : My example pattern context : items_title : Related pages my_objects : exists : true # simulate `QuerySet`'s `exists` method all : # simulate `QuerySet`'s `all` method - title : Page 1 link : /page1 - title : Page 2 link : /page2 You can define a list or a dict or anything that PyYAML allows you to create in YAML format without creating a custom objects. Modifying template contexts with Python \u00b6 While most objects can be faked with YAML, Django has a few common constructs that are difficult to replicate. For example: Form and Paginator instances. To help with this, django-pattern-library allows you to register any number of 'context modifiers'. Context modifiers are simply Python functions that accept the context dictionary generated from the YAML file, and can make additions or updates to it as necessary. For convenience, they also receive the current HttpRequest as request . Context modifiers can easily be registered using the register_context_modifier decorator. Here is a simple example: # myproject/core/pattern_contexts.py from pattern_library import register_context_modifier from myproject.core.forms import SearchForm , SignupForm @register_context_modifier def add_common_forms ( context , request ): if 'search_form' not in context : context [ \"search_form\" ] = SearchForm () if 'signup_form' not in context : context [ \"signup_form\" ] = SignupForm () Context modifiers are also great for reducing the amount of template tag patching that is needed. The following examples are from a Wagtail project: # myproject/core/pattern_contexts.py from django.core.paginator import Paginator from wagtail.images import get_image_model from pattern_library import register_context_modifier @register_context_modifier def add_page_images ( context , request ): \"\"\" Replace some common 'image' field values on pages with real `Image` instances, so that the {% image %} template tag will work. \"\"\" Image = get_image_model () if \"page\" in context : if \"hero_image\" in context [ \"page\" ]: context [ \"hero_image\" ] = Image . objects . all () . order ( \"?\" ) . first () if \"main_image\" in context [ \"page\" ]: context [ \"main_image\" ] = Image . objects . all () . order ( \"?\" ) . first () @register_context_modifier def replicate_pagination ( context , request ): \"\"\" Replace lists of items using the 'page_obj.object_list' key with a real Paginator page, and add a few other pagination-related things to the context (like Django's `ListView` does). \"\"\" object_list = context . pop ( 'page_obj.object_list' , None ) if object_list is None : return original_length = len ( object_list ) # add dummy items to force pagination for i in range ( 50 ): object_list . append ( None ) # paginate and add ListView-like values paginator = Paginator ( object_list , original_length ) context . update ( paginator = paginator , page_obj = paginator . page ( 1 ), is_paginated = True , object_list = object_list ) Registering a context modifier for a specific template \u00b6 By default, context modifiers are applied to all pattern library templates. If you only wish for a context modifier to be applied to a specific pattern, you can use the template parameter to indicate this. For example: # myproject/accounts/pattern_contexts.py from pattern_library import register_context_modifier from my_app.accounts.forms import SubscribeForm @register_context_modifier ( template = \"patterns/subscribe/form.html\" ) def add_subscribe_form ( context , request ): \"\"\" Adds an unbount form to 'form.html' \"\"\" context [ \"form\" ] = SubscribeForm () @register_context_modifier ( template = \"patterns/subscribe/form_invalid.html\" ) def add_invalid_subscribe_form ( context , request ): \"\"\" Adds a bound form with invalid data to 'form_invalid.html' \"\"\" context [ \"form\" ] = SubscribeForm ( data = { \"email\" : 'invalid-email' , \"name\" : '' }) Controlling the order in which context modifiers are applied \u00b6 By default, context modifiers are applied in the order they were registered (which can be difficult to predict across multiple apps), with generic context modifiers being applied first, followed by template-specific ones. If you need to control the order in which a series of context modifiers are applied, you can use the order parameter to do this. In the following example, a generic context modifier is registered with an order value of 1 , while others receive the default value of 0 . Because 1 is higher than 0 , the generic context modifier will be applied after the others. # myproject/sums/pattern_contexts.py from pattern_library import register_context_modifier @register_context_modifier ( template = 'patterns/sums/single_number.html' ) def add_single_number ( context , request ): context [ 'first_number' ] = 933 @register_context_modifier ( template = 'patterns/sums/two_numbers.html' ) def add_two_numbers ( context , request ): context [ 'first_number' ] = 125 context [ 'second_number' ] = 22 @register_context_modifier ( template = 'patterns/sums/three_numbers.html' ) def add_three_numbers ( context , request ): context [ 'first_number' ] = 125 context [ 'second_number' ] = 22 context [ 'third_number' ] = 9 @register_context_modifier ( order = 1 ) def add_total ( context , request ): if 'total' not in context : first_num = context . get ( 'first_number' , 0 ) second_num = context . get ( 'second_number' , 0 ) third_num = context . get ( 'third_number' , 0 ) context [ 'total' ] = first_num + second_num + third_num","title":"Template context"},{"location":"guides/defining-template-context/#defining-template-context","text":"To define fake context you need to create a YAML file alongside your template file. For example, for the template big_red_button.html you need to create a file called big_red_button.yaml . Let's imagine that your big_red_button.html template looks like this: <a href=\" {{ button_link }} \" class=\"button button--red\"> <span> {{ button_text }} </span> </a> The big_red_button.yaml can be something like this: context : button_link : https://example.com/ button_text : Example link In the same way you can provide context in more complex templates. Here is an example on how you can define fake context that pretends to be a QuerySet . Let's assume you have the following template: {% if my_objects.exists %} {{ items_title }} <ul> {% for obj in my_objects.all %} <li> <a href=\" {{ obj.link }} \"> {{ obj.title }} </a> </li> {% endfor %} </ul> {% endif %} You might define a YAML file similar to this to provide fake data: name : My example pattern context : items_title : Related pages my_objects : exists : true # simulate `QuerySet`'s `exists` method all : # simulate `QuerySet`'s `all` method - title : Page 1 link : /page1 - title : Page 2 link : /page2 You can define a list or a dict or anything that PyYAML allows you to create in YAML format without creating a custom objects.","title":"Defining template context"},{"location":"guides/defining-template-context/#modifying-template-contexts-with-python","text":"While most objects can be faked with YAML, Django has a few common constructs that are difficult to replicate. For example: Form and Paginator instances. To help with this, django-pattern-library allows you to register any number of 'context modifiers'. Context modifiers are simply Python functions that accept the context dictionary generated from the YAML file, and can make additions or updates to it as necessary. For convenience, they also receive the current HttpRequest as request . Context modifiers can easily be registered using the register_context_modifier decorator. Here is a simple example: # myproject/core/pattern_contexts.py from pattern_library import register_context_modifier from myproject.core.forms import SearchForm , SignupForm @register_context_modifier def add_common_forms ( context , request ): if 'search_form' not in context : context [ \"search_form\" ] = SearchForm () if 'signup_form' not in context : context [ \"signup_form\" ] = SignupForm () Context modifiers are also great for reducing the amount of template tag patching that is needed. The following examples are from a Wagtail project: # myproject/core/pattern_contexts.py from django.core.paginator import Paginator from wagtail.images import get_image_model from pattern_library import register_context_modifier @register_context_modifier def add_page_images ( context , request ): \"\"\" Replace some common 'image' field values on pages with real `Image` instances, so that the {% image %} template tag will work. \"\"\" Image = get_image_model () if \"page\" in context : if \"hero_image\" in context [ \"page\" ]: context [ \"hero_image\" ] = Image . objects . all () . order ( \"?\" ) . first () if \"main_image\" in context [ \"page\" ]: context [ \"main_image\" ] = Image . objects . all () . order ( \"?\" ) . first () @register_context_modifier def replicate_pagination ( context , request ): \"\"\" Replace lists of items using the 'page_obj.object_list' key with a real Paginator page, and add a few other pagination-related things to the context (like Django's `ListView` does). \"\"\" object_list = context . pop ( 'page_obj.object_list' , None ) if object_list is None : return original_length = len ( object_list ) # add dummy items to force pagination for i in range ( 50 ): object_list . append ( None ) # paginate and add ListView-like values paginator = Paginator ( object_list , original_length ) context . update ( paginator = paginator , page_obj = paginator . page ( 1 ), is_paginated = True , object_list = object_list )","title":"Modifying template contexts with Python"},{"location":"guides/defining-template-context/#registering-a-context-modifier-for-a-specific-template","text":"By default, context modifiers are applied to all pattern library templates. If you only wish for a context modifier to be applied to a specific pattern, you can use the template parameter to indicate this. For example: # myproject/accounts/pattern_contexts.py from pattern_library import register_context_modifier from my_app.accounts.forms import SubscribeForm @register_context_modifier ( template = \"patterns/subscribe/form.html\" ) def add_subscribe_form ( context , request ): \"\"\" Adds an unbount form to 'form.html' \"\"\" context [ \"form\" ] = SubscribeForm () @register_context_modifier ( template = \"patterns/subscribe/form_invalid.html\" ) def add_invalid_subscribe_form ( context , request ): \"\"\" Adds a bound form with invalid data to 'form_invalid.html' \"\"\" context [ \"form\" ] = SubscribeForm ( data = { \"email\" : 'invalid-email' , \"name\" : '' })","title":"Registering a context modifier for a specific template"},{"location":"guides/defining-template-context/#controlling-the-order-in-which-context-modifiers-are-applied","text":"By default, context modifiers are applied in the order they were registered (which can be difficult to predict across multiple apps), with generic context modifiers being applied first, followed by template-specific ones. If you need to control the order in which a series of context modifiers are applied, you can use the order parameter to do this. In the following example, a generic context modifier is registered with an order value of 1 , while others receive the default value of 0 . Because 1 is higher than 0 , the generic context modifier will be applied after the others. # myproject/sums/pattern_contexts.py from pattern_library import register_context_modifier @register_context_modifier ( template = 'patterns/sums/single_number.html' ) def add_single_number ( context , request ): context [ 'first_number' ] = 933 @register_context_modifier ( template = 'patterns/sums/two_numbers.html' ) def add_two_numbers ( context , request ): context [ 'first_number' ] = 125 context [ 'second_number' ] = 22 @register_context_modifier ( template = 'patterns/sums/three_numbers.html' ) def add_three_numbers ( context , request ): context [ 'first_number' ] = 125 context [ 'second_number' ] = 22 context [ 'third_number' ] = 9 @register_context_modifier ( order = 1 ) def add_total ( context , request ): if 'total' not in context : first_num = context . get ( 'first_number' , 0 ) second_num = context . get ( 'second_number' , 0 ) third_num = context . get ( 'third_number' , 0 ) context [ 'total' ] = first_num + second_num + third_num","title":"Controlling the order in which context modifiers are applied"},{"location":"guides/multiple-variants/","text":"Multiple template variants \u00b6 See #87 . There is currently no support for trying out a single component with different variations in context or tag overrides, but this can worked around by creating pattern-library-only templates. For example, for this call_to_action template: <div class=\"call-to-action\"> <img class=\"call-to-action__image\" src=\" {{ call_to_action.illustration.url }} \" alt=\"\"> <p class=\"call-to-action__heading heading heading--three\"> {{ call_to_action.title }} </p> {% include \"patterns/atoms/link/link.html\" with type = \"primary\" classes = \"call-to-action__link\" href = call_to_action.get_link_url text = call_to_action.get_link_text %} </div> We can try it out once with the following YAML: context : call_to_action : title : Will you help us protect these magnificant creatures in the UK waters? illustration : url : /static/images/illustrations/sharks.svg get_link_text : Sign up for our appeal get_link_url : '#' If we want to try multiple variants, simply create a custom template for pattern library usage only, that renders call_to_action multiple times: <div class=\"pl-frame pl-frame--white\"> <h2>Call to action</h2> {% for call_to_action in ctas %} <div class=\"pl-row {% if call_to_action.classes %}{{ call_to_action.classes }}{% endif %} \"> <p> {{ call_to_action.type }} </p> {% include \"patterns/molecules/cta/call_to_action.html\" with call_to_action = call_to_action %} </div> {% endfor %} </div> context : ctas : - type : Call to action title : Will you help us protect these magnificant creatures in the UK waters? illustration : url : /static/images/illustrations/sharks.svg get_link_text : Sign up for our appeal get_link_url : '#' - type : Call to action with short title title : Will you help us? illustration : url : /static/images/illustrations/sharks.svg get_link_text : Sign up for our appeal get_link_url : '#' - type : Call to action with long title title : Will you help us protect these magnificant and learn how to make environmentally responsible choices when buying seafood? illustration : url : /static/images/illustrations/sharks.svg get_link_text : Sign up for our appeal get_link_url : '#'","title":"Multiple variants"},{"location":"guides/multiple-variants/#multiple-template-variants","text":"See #87 . There is currently no support for trying out a single component with different variations in context or tag overrides, but this can worked around by creating pattern-library-only templates. For example, for this call_to_action template: <div class=\"call-to-action\"> <img class=\"call-to-action__image\" src=\" {{ call_to_action.illustration.url }} \" alt=\"\"> <p class=\"call-to-action__heading heading heading--three\"> {{ call_to_action.title }} </p> {% include \"patterns/atoms/link/link.html\" with type = \"primary\" classes = \"call-to-action__link\" href = call_to_action.get_link_url text = call_to_action.get_link_text %} </div> We can try it out once with the following YAML: context : call_to_action : title : Will you help us protect these magnificant creatures in the UK waters? illustration : url : /static/images/illustrations/sharks.svg get_link_text : Sign up for our appeal get_link_url : '#' If we want to try multiple variants, simply create a custom template for pattern library usage only, that renders call_to_action multiple times: <div class=\"pl-frame pl-frame--white\"> <h2>Call to action</h2> {% for call_to_action in ctas %} <div class=\"pl-row {% if call_to_action.classes %}{{ call_to_action.classes }}{% endif %} \"> <p> {{ call_to_action.type }} </p> {% include \"patterns/molecules/cta/call_to_action.html\" with call_to_action = call_to_action %} </div> {% endfor %} </div> context : ctas : - type : Call to action title : Will you help us protect these magnificant creatures in the UK waters? illustration : url : /static/images/illustrations/sharks.svg get_link_text : Sign up for our appeal get_link_url : '#' - type : Call to action with short title title : Will you help us? illustration : url : /static/images/illustrations/sharks.svg get_link_text : Sign up for our appeal get_link_url : '#' - type : Call to action with long title title : Will you help us protect these magnificant and learn how to make environmentally responsible choices when buying seafood? illustration : url : /static/images/illustrations/sharks.svg get_link_text : Sign up for our appeal get_link_url : '#'","title":"Multiple template variants"},{"location":"guides/overriding-template-tags/","text":"Overriding template tags \u00b6 The package overrides the following Django tags: {% extends %} {% include %} It's required to allow us to define fake template context and override other template tags in YAML files. This package uses custom behaviour for these tags only when rendering pattern library and falls back to Django's standard behaviour on all other cases. The override process has two parts: Override your template tag with a mock implementation Define fake result for your tag in a YAML file Providing a default value for template tags \u00b6 To provide a default for a template tag, you need to provide a keyword argument default_html when overriding your tag. from pattern_library.monkey_utils import override_tag override_tag ( register , 'a_tag_name' , default_html = \"https://example.com/\" ) This default is used for any tag that's not passed its own context, allowing specificity for those elements that need it while preventing the tag from breaking when it's not structural to the component. Limitation \u00b6 Currently this feature only supports providing a default for the output of the tag, this does not support modifying context in templates such as {% an_example_tag page.url as example_variable %} . When do I need to override a template tag? \u00b6 Ideally your pattern library should be independent, so it doesn't fail when you run it with a project that has no entries in DB or on a local machine without internet connection. This means that you need to override a template tag when it hits DB or any other resource (cache, or requests URL, for example). You amy also need to override template tags in other cases, when data provided by the pattern library\u2019s context mocking is of a different type to what Django would expect \u2013 this is because the pattern library only uses data types that are de-serializable from YAML. Override modes \u00b6 There are two options when it comes to template tag overriding: Render another template or pattern (a template with own fake context) instead of calling the original template tag Return raw data. For example, you can return a string, that will be rendered instead of the original template tag. You can also return a structure (dict or list) which is useful when overriding \"Simple tags\" or a custom tag that returns an object or dict Output into a variable \u00b6 Some tags can set their value into a variable like: {# renders something #} {% my_tag some_arg %} {# Outputs into a variable for later use #} {% my_tag some_arg as result_var %} {{ result_var.some_attr }} The package automatically detects an output variable ( result_var in our example) when a custom template tag is a \"Simple tag\" , so you don't need to worry about these tags. But when you need to override a tag which sets result into a variable in it's custom django.template.Node you would need to specify output var name manually. We will look into how to do that later in the examples section. Overriding examples \u00b6 Let's assume that we want to override the {% image image resize_rule %} template tag from the some_package.image_utils template tag set (you have something like {% load image_utils %} at the top of your template). This template tag resizes an image accordingly to a specific resize_rule and outputs the <img> html tag. It's also possible to assign an image object into a variable using this syntax: {% image image resize_rule as my_var_name %} . In this case tag doesn't render the <img> tag, but you can access image object's properties ( my_var_name.url , for example). First, we need to override a template tag with fake implementation. Note that the fake implementation will only be used when viewing the pattern library: you will be using the actual implementation in our production code. Assuming that you already have module installed in your project, to define a fake implementation we need to: First, create a templatetags package in one of your apps. Note that your app should be defined in INSTALLED_APPS and it should be defined after the package you are overriding ( some_package in our case). Then, create image_utils.py in this package with the following code: from some_package.templatetags.image_utils import register from pattern_library.monkey_utils import override_tag # We are monkey patching here # Note that `register` should be an instance of `django.template.Library` # and it's important to the instance where the original tag is defined. override_tag ( register , name = 'image' ) Note: it's recommended to have a single app that contains all template tag overrides, so it's easy to exclude it from INSTALLED_APPS in production, if you want to. Now we need to define fake result for each instance of our template tag. Let's assume that we have a template with two calls of the {% image $} template tag: ` {% load image_utils %} ` <div class=\"user\"> <div class=\"user-avatar\"> {% image avatar fill-200x200 %} </div> <div class=\"user-data\"> <div>Username: {{ username }} </div> <div> <div>User photo:</div> {% image avatar fill-200x400 %} </div> </div> </div> Render another template or pattern \u00b6 Our yaml will similar to this: # Override template tags tags : # Name of the template tag we are overriding image : # Arguments of the template tag # Override {% image avatar fill-200x200 %} avatar fill-200x200 : template_name : \"patterns/atoms/images/image.html\" # Override {% image avatar fill-200x400 %} avatar fill-200x400 : template_name : \"patterns/atoms/images/image.html\" # Override context, if needed In this example, we override both template tags and render the same template: patterns/atoms/images/image.html . This template is a regular Django template. If it's a pattern, like in our example, it will be rendered with its own fake content defined in patterns/atoms/images/image.yaml . The downside of this approach is that we render the same template where an image can be rendered in a different size. So, if patterns/atoms/images/image.html has something like <img src=\"http://via.placeholder.com/200x200\" width=\"200\" height=\"200\" alt=\"Placeholder\"> inside, this means that we will render image of size 200x200 few times. Probably, in the majority of cases, it's ok to render the same template, but not when we are rendering images of different sizes. There are two approaches for this problem: Create a template for every image size you need. It can be a template that you will be only using for pattern library: no production use. This is a good option, when you want define a fake result for a template tag that renders a big piece of HTML code. Also it's useful when the template tag renders some other pattern, which is a common situation. For tags that render something small like <img> tag, there is an alternative option: you can define raw data in your yaml file Return raw data \u00b6 Let's update our yaml to use raw data: # Override template tags tags : # Name of the template tag we are overriding image : # Arguments of the template tag # Override {% image avatar fill-200x200 %} avatar fill-200x200 : raw : > <img src=\"http://via.placeholder.com/200x200\" width=\"200\" height=\"200\" alt=\"Placeholder\"> # Override {% image avatar fill-200x400 %} avatar fill-200x400 : raw : > <img src=\"http://via.placeholder.com/200x400\" width=\"200\" height=\"400\" alt=\"Placeholder\"> # Override context, if needed Now we make both {% image %} tags return different strings without creating a separate templates for them. The raw field, can contain any data supported by PyYAML without creating a custom object type. For example, if we have a template like this: {% comment %} The following tag assigns result into avatar_thumbnail for later use and renders nothing (empty string). {% endcomment %} {% image avatar fill-200x200 as avatar_thumbnail %} Avatar file path: {{ avatar_thumbnail.file }} Avatar URL: {{ avatar_thumbnail.url }} Avatar: <img src=\" {{ avatar_thumbnail.url }} \" alt=\" {{ username }} \"> We can define our yaml like this: tags : image : # Override {% image avatar fill-200x200 as avatar_thumbnail %} avatar fill-200x200 as avatar_thumbnail : raw : file : \"/path/to/avatar/file\" url : \"http://via.placeholder.com/200x200\" Note that the example above will only work if our image is a \"Simple tag\" . If it's a more custom implementation, we will need to specify output variable name explicitly like this: tags : image : # Override {% image avatar fill-200x200 as avatar_thumbnail %} avatar fill-200x200 as avatar_thumbnail : target_var : avatar_thumbnail raw : file : \"/path/to/avatar/file\" url : \"http://via.placeholder.com/200x200\" Note the target_var field.","title":"Overriding tags"},{"location":"guides/overriding-template-tags/#overriding-template-tags","text":"The package overrides the following Django tags: {% extends %} {% include %} It's required to allow us to define fake template context and override other template tags in YAML files. This package uses custom behaviour for these tags only when rendering pattern library and falls back to Django's standard behaviour on all other cases. The override process has two parts: Override your template tag with a mock implementation Define fake result for your tag in a YAML file","title":"Overriding template tags"},{"location":"guides/overriding-template-tags/#providing-a-default-value-for-template-tags","text":"To provide a default for a template tag, you need to provide a keyword argument default_html when overriding your tag. from pattern_library.monkey_utils import override_tag override_tag ( register , 'a_tag_name' , default_html = \"https://example.com/\" ) This default is used for any tag that's not passed its own context, allowing specificity for those elements that need it while preventing the tag from breaking when it's not structural to the component.","title":"Providing a default value for template tags"},{"location":"guides/overriding-template-tags/#limitation","text":"Currently this feature only supports providing a default for the output of the tag, this does not support modifying context in templates such as {% an_example_tag page.url as example_variable %} .","title":"Limitation"},{"location":"guides/overriding-template-tags/#when-do-i-need-to-override-a-template-tag","text":"Ideally your pattern library should be independent, so it doesn't fail when you run it with a project that has no entries in DB or on a local machine without internet connection. This means that you need to override a template tag when it hits DB or any other resource (cache, or requests URL, for example). You amy also need to override template tags in other cases, when data provided by the pattern library\u2019s context mocking is of a different type to what Django would expect \u2013 this is because the pattern library only uses data types that are de-serializable from YAML.","title":"When do I need to override a template tag?"},{"location":"guides/overriding-template-tags/#override-modes","text":"There are two options when it comes to template tag overriding: Render another template or pattern (a template with own fake context) instead of calling the original template tag Return raw data. For example, you can return a string, that will be rendered instead of the original template tag. You can also return a structure (dict or list) which is useful when overriding \"Simple tags\" or a custom tag that returns an object or dict","title":"Override modes"},{"location":"guides/overriding-template-tags/#output-into-a-variable","text":"Some tags can set their value into a variable like: {# renders something #} {% my_tag some_arg %} {# Outputs into a variable for later use #} {% my_tag some_arg as result_var %} {{ result_var.some_attr }} The package automatically detects an output variable ( result_var in our example) when a custom template tag is a \"Simple tag\" , so you don't need to worry about these tags. But when you need to override a tag which sets result into a variable in it's custom django.template.Node you would need to specify output var name manually. We will look into how to do that later in the examples section.","title":"Output into a variable"},{"location":"guides/overriding-template-tags/#overriding-examples","text":"Let's assume that we want to override the {% image image resize_rule %} template tag from the some_package.image_utils template tag set (you have something like {% load image_utils %} at the top of your template). This template tag resizes an image accordingly to a specific resize_rule and outputs the <img> html tag. It's also possible to assign an image object into a variable using this syntax: {% image image resize_rule as my_var_name %} . In this case tag doesn't render the <img> tag, but you can access image object's properties ( my_var_name.url , for example). First, we need to override a template tag with fake implementation. Note that the fake implementation will only be used when viewing the pattern library: you will be using the actual implementation in our production code. Assuming that you already have module installed in your project, to define a fake implementation we need to: First, create a templatetags package in one of your apps. Note that your app should be defined in INSTALLED_APPS and it should be defined after the package you are overriding ( some_package in our case). Then, create image_utils.py in this package with the following code: from some_package.templatetags.image_utils import register from pattern_library.monkey_utils import override_tag # We are monkey patching here # Note that `register` should be an instance of `django.template.Library` # and it's important to the instance where the original tag is defined. override_tag ( register , name = 'image' ) Note: it's recommended to have a single app that contains all template tag overrides, so it's easy to exclude it from INSTALLED_APPS in production, if you want to. Now we need to define fake result for each instance of our template tag. Let's assume that we have a template with two calls of the {% image $} template tag: ` {% load image_utils %} ` <div class=\"user\"> <div class=\"user-avatar\"> {% image avatar fill-200x200 %} </div> <div class=\"user-data\"> <div>Username: {{ username }} </div> <div> <div>User photo:</div> {% image avatar fill-200x400 %} </div> </div> </div>","title":"Overriding examples"},{"location":"guides/overriding-template-tags/#render-another-template-or-pattern","text":"Our yaml will similar to this: # Override template tags tags : # Name of the template tag we are overriding image : # Arguments of the template tag # Override {% image avatar fill-200x200 %} avatar fill-200x200 : template_name : \"patterns/atoms/images/image.html\" # Override {% image avatar fill-200x400 %} avatar fill-200x400 : template_name : \"patterns/atoms/images/image.html\" # Override context, if needed In this example, we override both template tags and render the same template: patterns/atoms/images/image.html . This template is a regular Django template. If it's a pattern, like in our example, it will be rendered with its own fake content defined in patterns/atoms/images/image.yaml . The downside of this approach is that we render the same template where an image can be rendered in a different size. So, if patterns/atoms/images/image.html has something like <img src=\"http://via.placeholder.com/200x200\" width=\"200\" height=\"200\" alt=\"Placeholder\"> inside, this means that we will render image of size 200x200 few times. Probably, in the majority of cases, it's ok to render the same template, but not when we are rendering images of different sizes. There are two approaches for this problem: Create a template for every image size you need. It can be a template that you will be only using for pattern library: no production use. This is a good option, when you want define a fake result for a template tag that renders a big piece of HTML code. Also it's useful when the template tag renders some other pattern, which is a common situation. For tags that render something small like <img> tag, there is an alternative option: you can define raw data in your yaml file","title":"Render another template or pattern"},{"location":"guides/overriding-template-tags/#return-raw-data","text":"Let's update our yaml to use raw data: # Override template tags tags : # Name of the template tag we are overriding image : # Arguments of the template tag # Override {% image avatar fill-200x200 %} avatar fill-200x200 : raw : > <img src=\"http://via.placeholder.com/200x200\" width=\"200\" height=\"200\" alt=\"Placeholder\"> # Override {% image avatar fill-200x400 %} avatar fill-200x400 : raw : > <img src=\"http://via.placeholder.com/200x400\" width=\"200\" height=\"400\" alt=\"Placeholder\"> # Override context, if needed Now we make both {% image %} tags return different strings without creating a separate templates for them. The raw field, can contain any data supported by PyYAML without creating a custom object type. For example, if we have a template like this: {% comment %} The following tag assigns result into avatar_thumbnail for later use and renders nothing (empty string). {% endcomment %} {% image avatar fill-200x200 as avatar_thumbnail %} Avatar file path: {{ avatar_thumbnail.file }} Avatar URL: {{ avatar_thumbnail.url }} Avatar: <img src=\" {{ avatar_thumbnail.url }} \" alt=\" {{ username }} \"> We can define our yaml like this: tags : image : # Override {% image avatar fill-200x200 as avatar_thumbnail %} avatar fill-200x200 as avatar_thumbnail : raw : file : \"/path/to/avatar/file\" url : \"http://via.placeholder.com/200x200\" Note that the example above will only work if our image is a \"Simple tag\" . If it's a more custom implementation, we will need to specify output variable name explicitly like this: tags : image : # Override {% image avatar fill-200x200 as avatar_thumbnail %} avatar fill-200x200 as avatar_thumbnail : target_var : avatar_thumbnail raw : file : \"/path/to/avatar/file\" url : \"http://via.placeholder.com/200x200\" Note the target_var field.","title":"Return raw data"},{"location":"guides/reuse-across-projects/","text":"Reuse across projects \u00b6 django-pattern-library is designed to be useful for component reuse within a single project, but it can also be set up to create a component library reusable between multiple projects. Reusing pattern library components is a matter of packaging and publishing a Django app (that happens to contain a lot of templates, CSS, and JS). Here are the rough steps: Decide where to store the shared pattern library . Whether it has its own repository, whether it\u2019s published on PyPI, or in another way. Choose a versioning and release methodology . With multiple projects reusing the code, it\u2019s important for them to be able to pin specific versions, and have a clear sense of how to do updates. Provide a pattern library development environment . Developers will need a way to iterate on pattern library components in isolation from the projects the UI components are reused in. Static files \u00b6 As part of your pattern library\u2019s build process, make sure that the static files (CSS, JS, etc.) of each component can be reused individually of each-other. Different projects likely will reuse different components, and you don\u2019t want to be paying the performance cost of loading components you don\u2019t need. Useful resources \u00b6 Django\u2019s official How to write reusable apps InVision\u2019s Guide to Design Systems","title":"Reuse across projects"},{"location":"guides/reuse-across-projects/#reuse-across-projects","text":"django-pattern-library is designed to be useful for component reuse within a single project, but it can also be set up to create a component library reusable between multiple projects. Reusing pattern library components is a matter of packaging and publishing a Django app (that happens to contain a lot of templates, CSS, and JS). Here are the rough steps: Decide where to store the shared pattern library . Whether it has its own repository, whether it\u2019s published on PyPI, or in another way. Choose a versioning and release methodology . With multiple projects reusing the code, it\u2019s important for them to be able to pin specific versions, and have a clear sense of how to do updates. Provide a pattern library development environment . Developers will need a way to iterate on pattern library components in isolation from the projects the UI components are reused in.","title":"Reuse across projects"},{"location":"guides/reuse-across-projects/#static-files","text":"As part of your pattern library\u2019s build process, make sure that the static files (CSS, JS, etc.) of each component can be reused individually of each-other. Different projects likely will reuse different components, and you don\u2019t want to be paying the performance cost of loading components you don\u2019t need.","title":"Static files"},{"location":"guides/reuse-across-projects/#useful-resources","text":"Django\u2019s official How to write reusable apps InVision\u2019s Guide to Design Systems","title":"Useful resources"},{"location":"guides/static-site-export/","text":"Static site export \u00b6 It can be useful to publish your pattern library as a static site \u2013 for example to host it without a runtime dependency on the rest of your code, or to save past versions, or save the output as build artifacts. With render_patterns \u00b6 The render_patterns command command can be used to export all your templates, without exporting the pattern library UI. # Export all templates, wrapped in the base template like the pattern library UI does. ./manage.py render_patterns --wrap-fragments --output dpl-rendered-patterns # Or alternatively export all templates without extra wrapping. ./manage.py render_patterns --output dpl-rendered-patterns This command will create a new folder, with a structure matching that of your templates: dpl-rendered-patterns \u251c\u2500\u2500 atoms \u2502 \u251c\u2500\u2500 icons \u2502 \u2502 \u2514\u2500\u2500 icon.html \u251c\u2500\u2500 molecules \u2502 \u251c\u2500\u2500 accordion \u2502 \u2502 \u2514\u2500\u2500 accordion.html \u2514\u2500\u2500 pages \u2514\u2500\u2500 people \u2514\u2500\u2500 person_page.html Note this will export all templates but won\u2019t export static files. If you need static files for your export, additionally run collectstatic , and move its output to be where STATIC_URL expects it: ./manage.py collectstatic # Moving the collected files to match STATIC_URL mv static dpl-rendered-patterns/static With a website scrapper \u00b6 It\u2019s very straightforward to export the whole pattern library as a static site, including all templates, and the pattern library UI. Here is an example exporting the pattern library with wget : wget --mirror --page-requisites --no-parent http://localhost:8000/pattern-library/","title":"Static site export"},{"location":"guides/static-site-export/#static-site-export","text":"It can be useful to publish your pattern library as a static site \u2013 for example to host it without a runtime dependency on the rest of your code, or to save past versions, or save the output as build artifacts.","title":"Static site export"},{"location":"guides/static-site-export/#with-render_patterns","text":"The render_patterns command command can be used to export all your templates, without exporting the pattern library UI. # Export all templates, wrapped in the base template like the pattern library UI does. ./manage.py render_patterns --wrap-fragments --output dpl-rendered-patterns # Or alternatively export all templates without extra wrapping. ./manage.py render_patterns --output dpl-rendered-patterns This command will create a new folder, with a structure matching that of your templates: dpl-rendered-patterns \u251c\u2500\u2500 atoms \u2502 \u251c\u2500\u2500 icons \u2502 \u2502 \u2514\u2500\u2500 icon.html \u251c\u2500\u2500 molecules \u2502 \u251c\u2500\u2500 accordion \u2502 \u2502 \u2514\u2500\u2500 accordion.html \u2514\u2500\u2500 pages \u2514\u2500\u2500 people \u2514\u2500\u2500 person_page.html Note this will export all templates but won\u2019t export static files. If you need static files for your export, additionally run collectstatic , and move its output to be where STATIC_URL expects it: ./manage.py collectstatic # Moving the collected files to match STATIC_URL mv static dpl-rendered-patterns/static","title":"With render_patterns"},{"location":"guides/static-site-export/#with-a-website-scrapper","text":"It\u2019s very straightforward to export the whole pattern library as a static site, including all templates, and the pattern library UI. Here is an example exporting the pattern library with wget : wget --mirror --page-requisites --no-parent http://localhost:8000/pattern-library/","title":"With a website scrapper"},{"location":"guides/usage-tips/","text":"Usage tips \u00b6 The workflow of developing UI components in a pattern library can be quite different from one-off templates that are only rendered where they are used. Here are tips to make the most of it. Keep the pattern library in sync \u00b6 One of the upsides of having the pattern library built with Django is that the HTML templates can never go out of sync \u2013 but the data can! Make sure your template context and tag overrides keep in sync with your actual templates. This can for example be part of a code review checklist. You may also consider using the render_patterns command to have a baseline check the patterns don\u2019t raise errors while rendering. Document your patterns \u00b6 Patterns support defining a custom name in YAML, as well as rendering fully-fledged documentation in Markdown. Create a file next to the template to document it: This template can be used in different places. In streamfield block or directly in a page template. To use this template pass `call_to_action` into context. Example: {% include \"patterns/molecules/cta/call_to_action.html\" with call_to_action=call_to_action %} Test faster \u00b6 One of the main points of maintaining a pattern library is to be able to work on UI components in isolation from where they are used, which is very useful when testing components \u2013 access them directly in the pattern library, rather than always having to figure out where they are used, and manually navigating to them. You can use the pattern library\u2019s iframe view directly to test the component without the pattern library UI, but remember that the pattern will be displayed wrapped in the base template ( PATTERN_BASE_TEMPLATE_NAME ), which isn\u2019t always truthful to how components are used in situ. A pattern library can also help with automated tests . Iterate on components \u00b6 Back-end first \u00b6 Traditionally, Django development starts from models, and everything else is derived from the models\u2019 structure. This is very natural from a back-end perspective \u2013 first define your data model, then the view(s) that reuse it, and finally templates. We generally recommend this approach, but keep in mind that: With this workflow it\u2019s natural to write templates that are heavily tied to the database structure, and as such not very reusable, and may be out of touch with visual design. There can be work needed later on to reconcile the data structure as defined by the back-end, with what is mandated by the designs. To mitigate this risk, and overall make templates more reusable, take the time to massage data into basic structures that map better to visual representations. Front-end first \u00b6 Alternatively, the pattern library makes it possible to write templates without models and views. This can be very convenient if your project\u2019s schedule requires this kind of progression. With this approach, keep in mind that: When creating the template from UI principles, there will be assumptions made about the underlying data structures to be provided by Django models. Templates will be heavily tied to their visual design (which generally uses basic data structures like lists and mappings), and may be out of touch with the models once they are created. There will be work to do to reconcile the data structure as defined in the UI components, with what is mandated by the models. Here as well, to mitigate this risk, and overall make templates more reusable, take the time to massage data into basic structures that map better to visual representations.","title":"Usage tips"},{"location":"guides/usage-tips/#usage-tips","text":"The workflow of developing UI components in a pattern library can be quite different from one-off templates that are only rendered where they are used. Here are tips to make the most of it.","title":"Usage tips"},{"location":"guides/usage-tips/#keep-the-pattern-library-in-sync","text":"One of the upsides of having the pattern library built with Django is that the HTML templates can never go out of sync \u2013 but the data can! Make sure your template context and tag overrides keep in sync with your actual templates. This can for example be part of a code review checklist. You may also consider using the render_patterns command to have a baseline check the patterns don\u2019t raise errors while rendering.","title":"Keep the pattern library in sync"},{"location":"guides/usage-tips/#document-your-patterns","text":"Patterns support defining a custom name in YAML, as well as rendering fully-fledged documentation in Markdown. Create a file next to the template to document it: This template can be used in different places. In streamfield block or directly in a page template. To use this template pass `call_to_action` into context. Example: {% include \"patterns/molecules/cta/call_to_action.html\" with call_to_action=call_to_action %}","title":"Document your patterns"},{"location":"guides/usage-tips/#test-faster","text":"One of the main points of maintaining a pattern library is to be able to work on UI components in isolation from where they are used, which is very useful when testing components \u2013 access them directly in the pattern library, rather than always having to figure out where they are used, and manually navigating to them. You can use the pattern library\u2019s iframe view directly to test the component without the pattern library UI, but remember that the pattern will be displayed wrapped in the base template ( PATTERN_BASE_TEMPLATE_NAME ), which isn\u2019t always truthful to how components are used in situ. A pattern library can also help with automated tests .","title":"Test faster"},{"location":"guides/usage-tips/#iterate-on-components","text":"","title":"Iterate on components"},{"location":"guides/usage-tips/#back-end-first","text":"Traditionally, Django development starts from models, and everything else is derived from the models\u2019 structure. This is very natural from a back-end perspective \u2013 first define your data model, then the view(s) that reuse it, and finally templates. We generally recommend this approach, but keep in mind that: With this workflow it\u2019s natural to write templates that are heavily tied to the database structure, and as such not very reusable, and may be out of touch with visual design. There can be work needed later on to reconcile the data structure as defined by the back-end, with what is mandated by the designs. To mitigate this risk, and overall make templates more reusable, take the time to massage data into basic structures that map better to visual representations.","title":"Back-end first"},{"location":"guides/usage-tips/#front-end-first","text":"Alternatively, the pattern library makes it possible to write templates without models and views. This can be very convenient if your project\u2019s schedule requires this kind of progression. With this approach, keep in mind that: When creating the template from UI principles, there will be assumptions made about the underlying data structures to be provided by Django models. Templates will be heavily tied to their visual design (which generally uses basic data structures like lists and mappings), and may be out of touch with the models once they are created. There will be work to do to reconcile the data structure as defined in the UI components, with what is mandated by the models. Here as well, to mitigate this risk, and overall make templates more reusable, take the time to massage data into basic structures that map better to visual representations.","title":"Front-end first"},{"location":"recipes/forms-and-fields/","text":"Forms and fields \u00b6 Basic Django form definition: from django import forms class ExampleForm ( forms . Form ): single_line_text = forms . CharField ( max_length = 255 , help_text = \"This is some help text\" ) choices = (( \"one\" , \"One\" ), ( \"two\" , \"Two\" ), ( \"three\" , \"Three\" ), ( \"four\" , \"Four\" )) select = forms . ChoiceField ( choices = choices ) Rendered as: {% extends \"patterns/base.html\" %} {% block content %} <form method= \"post\" class= \"form\" > {% csrf_token %} <div class= \"form__container\" > {% for hidden_field in form.hidden_fields %} {{ hidden_field }} {% endfor %} {% for field in form.visible_fields %} {% include \"patterns/molecules/field/field.html\" with field = field %} {% endfor %} <button class= \"form__submit button\" type= \"submit\" > Submit </button> </div> </form> {% endblock %} Context overrides when rendering the whole form: from pattern_library import register_context_modifier from .forms import ExampleForm @register_context_modifier def add_common_forms ( context , request ): context [ 'form' ] = ExampleForm () Context overrides for field.html : from pattern_library import register_context_modifier from .forms import ExampleForm @register_context_modifier ( template = 'patterns/molecules/field/field.html' ) def add_field ( context , request ): form = ExampleForm () context [ 'field' ] = form [ 'single_line_text' ]","title":"Forms and fields"},{"location":"recipes/forms-and-fields/#forms-and-fields","text":"Basic Django form definition: from django import forms class ExampleForm ( forms . Form ): single_line_text = forms . CharField ( max_length = 255 , help_text = \"This is some help text\" ) choices = (( \"one\" , \"One\" ), ( \"two\" , \"Two\" ), ( \"three\" , \"Three\" ), ( \"four\" , \"Four\" )) select = forms . ChoiceField ( choices = choices ) Rendered as: {% extends \"patterns/base.html\" %} {% block content %} <form method= \"post\" class= \"form\" > {% csrf_token %} <div class= \"form__container\" > {% for hidden_field in form.hidden_fields %} {{ hidden_field }} {% endfor %} {% for field in form.visible_fields %} {% include \"patterns/molecules/field/field.html\" with field = field %} {% endfor %} <button class= \"form__submit button\" type= \"submit\" > Submit </button> </div> </form> {% endblock %} Context overrides when rendering the whole form: from pattern_library import register_context_modifier from .forms import ExampleForm @register_context_modifier def add_common_forms ( context , request ): context [ 'form' ] = ExampleForm () Context overrides for field.html : from pattern_library import register_context_modifier from .forms import ExampleForm @register_context_modifier ( template = 'patterns/molecules/field/field.html' ) def add_field ( context , request ): form = ExampleForm () context [ 'field' ] = form [ 'single_line_text' ]","title":"Forms and fields"},{"location":"recipes/image-include/","text":"Image include \u00b6 < img src = \"{{ imageSmall.url }}\" data - src = \"{{ imageLarge.url }}\" width = \"{{ width }}\" height = \"{{ height }}\" alt = \"{{ imageLarge.alt }}\" class = \"{{ classList }} lazyload\" > YAML: context : width : '720' height : '400' imageSmall : url : https://source.unsplash.com/pZ-XFIrJMtE/360x200 imageLarge : url : https://source.unsplash.com/pZ-XFIrJMtE/720x400","title":"Image include"},{"location":"recipes/image-include/#image-include","text":"< img src = \"{{ imageSmall.url }}\" data - src = \"{{ imageLarge.url }}\" width = \"{{ width }}\" height = \"{{ height }}\" alt = \"{{ imageLarge.alt }}\" class = \"{{ classList }} lazyload\" > YAML: context : width : '720' height : '400' imageSmall : url : https://source.unsplash.com/pZ-XFIrJMtE/360x200 imageLarge : url : https://source.unsplash.com/pZ-XFIrJMtE/720x400","title":"Image include"},{"location":"recipes/image-lazyload/","text":"Image lazy load \u00b6 { % image slide . image fill - 100 x71 as imageSmall % } { % image slide . image fill - 829 x585 as imageLarge % } { % include \"patterns/atoms/image/image--lazyload.html\" with imageSmall = imageSmall width = 829 height = 585 imageLarge = imageLarge classList = 'slide__image' % } tags : image : slide.image fill-100x71 as imageSmall : target_var : imageSmall raw : url : '//placekitten.com/100/71' slide.image fill-829x585 as imageLarge : target_var : imageLarge raw : url : '//placekitten.com/829/585' width : '829' height : '585'","title":"Image lazyload"},{"location":"recipes/image-lazyload/#image-lazy-load","text":"{ % image slide . image fill - 100 x71 as imageSmall % } { % image slide . image fill - 829 x585 as imageLarge % } { % include \"patterns/atoms/image/image--lazyload.html\" with imageSmall = imageSmall width = 829 height = 585 imageLarge = imageLarge classList = 'slide__image' % } tags : image : slide.image fill-100x71 as imageSmall : target_var : imageSmall raw : url : '//placekitten.com/100/71' slide.image fill-829x585 as imageLarge : target_var : imageLarge raw : url : '//placekitten.com/829/585' width : '829' height : '585'","title":"Image lazy load"},{"location":"recipes/inclusion-tags/","text":"Inclusion tags \u00b6 <div class= \"footer__action\" > {% footernav %} </div> tags : footernav : \"\" : template_name : \"patterns/molecules/navigation/footernav.html\"","title":"Inclusion tags"},{"location":"recipes/inclusion-tags/#inclusion-tags","text":"<div class= \"footer__action\" > {% footernav %} </div> tags : footernav : \"\" : template_name : \"patterns/molecules/navigation/footernav.html\"","title":"Inclusion tags"},{"location":"recipes/looping-for-tags/","text":"Looping over a template tag \u00b6 For a template such as: {% social_media_links as social_links %} <ul class= \"footer__social-links\" > {% for link in social_links %} {# Only render if we have a link #} {% if link.url %} <li class= \"social-item social-item-- {{ link.type }} \" > <a class= \"social-item__link\" href= \" {{ link.url }} \" aria-label= \" {{ link.label }} \" > <svg class= \"social-item__icon\" width= \"24\" height= \"24\" aria-hidden= \"true\" focusable= \"false\" > <use xlink:href= \"# {{ link.type }} \" ></use> </svg> </a> </li> {% endif %} {% endfor %} </ul> You can use the following syntax to mock the tag\u2019s output: tags : social_media_links : as social_links : raw : - url : '#' type : twitter label : Twitter - url : '#' type : facebook label : Facebook - url : '#' type : instagram label : Instagram - url : '#' type : youtube label : YouTube - url : '#' type : linkedin label : LinkedIn","title":"Looping for tags"},{"location":"recipes/looping-for-tags/#looping-over-a-template-tag","text":"For a template such as: {% social_media_links as social_links %} <ul class= \"footer__social-links\" > {% for link in social_links %} {# Only render if we have a link #} {% if link.url %} <li class= \"social-item social-item-- {{ link.type }} \" > <a class= \"social-item__link\" href= \" {{ link.url }} \" aria-label= \" {{ link.label }} \" > <svg class= \"social-item__icon\" width= \"24\" height= \"24\" aria-hidden= \"true\" focusable= \"false\" > <use xlink:href= \"# {{ link.type }} \" ></use> </svg> </a> </li> {% endif %} {% endfor %} </ul> You can use the following syntax to mock the tag\u2019s output: tags : social_media_links : as social_links : raw : - url : '#' type : twitter label : Twitter - url : '#' type : facebook label : Facebook - url : '#' type : instagram label : Instagram - url : '#' type : youtube label : YouTube - url : '#' type : linkedin label : LinkedIn","title":"Looping over a template tag"},{"location":"reference/api/","text":"API and settings \u00b6 YAML structure \u00b6 YAML isn\u2019t everyone\u2019s favorite markup language, but it has the advantage of being very lean, mapping well to both JSON and Python data structures, and supporting comments. Here is what you need to know: Always use .yaml for patterns configuration. Use Mappings in place of Python Dictionaries. Use Sequences in place of Python lists (or iterables like QuerySets). The pattern library uses PyYAML in particular Here is an example in practice: name : Test # Nested structure, dependent on template. context : quote : What is love? attribution : Haddaway my_list : - 1 - 2 - 3 # Mapping from tag names to tag overrides. tags : error_tag : include : template_name : \"non-patterns/include.html\" Templates \u00b6 pattern_library_rendered_pattern \u00b6 pattern_library_rendered_pattern is required in the template defined as PATTERN_BASE_TEMPLATE_NAME . This gets replaced by the rendered pattern\u2019s HTML when displaying patterns in the library. <body> {% block content %}{{ pattern_library_rendered_pattern }}{% endblock %} </body> Settings \u00b6 See Getting started for more guided information. PATTERN_LIBRARY \u00b6 All settings should be set as keys of the PATTERN_LIBRARY object. PATTERN_LIBRARY = { # [\u2026] } SECTIONS \u00b6 SECTIONS controls the groups of templates that appear in the navigation. The keys are the group titles and the values are lists of template name prefixes that will be searched to populate the groups. The pattern library searches for templates both in DIRS directories for template engines, and in the templates subdirectory inside each installed application if using APP_DIRS . You can use this to create basic two-folder \"includes and pages\" hierarchies: PATTERN_LIBRARY = { \"SECTIONS\" : ( ( \"components\" , [ \"patterns/components\" ]), ( \"pages\" , [ \"patterns/pages\" ]), ), } Or more detailed structures following Atomic Design : PATTERN_LIBRARY = { \"SECTIONS\" : ( ( \"atoms\" , [ \"patterns/atoms\" ]), ( \"molecules\" , [ \"patterns/molecules\" ]), ( \"organisms\" , [ \"patterns/organisms\" ]), ( \"templates\" , [ \"patterns/templates\" ]), ( \"pages\" , [ \"patterns/pages\" ]), ), } TEMPLATE_SUFFIX \u00b6 Defaults to .html . Only set this if your templates use another file extension. PATTERN_LIBRARY = { \"TEMPLATE_SUFFIX\" : \".dj\" , } PATTERN_BASE_TEMPLATE_NAME \u00b6 PATTERN_BASE_TEMPLATE_NAME is the template that fragments will be wrapped with. It should include any required CSS and JS, and output pattern_library_rendered_pattern from context. PATTERN_LIBRARY = { \"PATTERN_BASE_TEMPLATE_NAME\" : \"patterns/base.html\" , } BASE_TEMPLATE_NAMES \u00b6 Any template in BASE_TEMPLATE_NAMES or any template that extends a template in BASE_TEMPLATE_NAMES is a \"page\" and will be rendered as-is without being wrapped. PATTERN_LIBRARY = { \"BASE_TEMPLATE_NAMES\" : [ \"patterns/base_page.html\" ], } monkey_utils \u00b6 override_tag \u00b6 This function tells the pattern library which Django tags to override, and optionally supports providing a default value. See Overriding template tags for more information. from pattern_library.monkey_utils import override_tag override_tag ( register , 'a_tag_name' , default_html = \"https://example.com/\" ) register_context_modifier \u00b6 This decorator makes it possible to override or create additional context data with Django / Python code, rather than being limited to YAML. It has to be called from within a pattern_contexts module, which can be at the root of any Django app. See Modifying template contexts with Python for more information. # myproject/core/pattern_contexts.py from pattern_library import register_context_modifier from myproject.core.forms import SearchForm , SignupForm @register_context_modifier def add_common_forms ( context , request ): if 'search_form' not in context : context [ \"search_form\" ] = SearchForm () Commands \u00b6 render_patterns \u00b6 Renders all django-pattern-library patterns to HTML files, in a directory structure. This can be useful for automated tests . Usage: # Render all patterns to the default directory. ./manage.py render_patterns # Render patterns without outputting files. ./manage.py render_patterns --dry-run # Render all patterns, with fragment patterns wrapped in the base template. ./manage.py render_patterns --wrap-fragments # Render patterns to a specific directory. ./manage.py render_patterns --output ./my/path/relative/to/cwd # Render patterns to stdout. ./manage.py render_patterns --dry-run --verbosity 2 # View all options ./manage.py render_patterns --help By default patterns will be saved in a dpl-rendered-patterns folder. Make sure to add this to your .gitignore and other ignore files, or customize the output directory with --output .","title":"API and settings"},{"location":"reference/api/#api-and-settings","text":"","title":"API and settings"},{"location":"reference/api/#yaml-structure","text":"YAML isn\u2019t everyone\u2019s favorite markup language, but it has the advantage of being very lean, mapping well to both JSON and Python data structures, and supporting comments. Here is what you need to know: Always use .yaml for patterns configuration. Use Mappings in place of Python Dictionaries. Use Sequences in place of Python lists (or iterables like QuerySets). The pattern library uses PyYAML in particular Here is an example in practice: name : Test # Nested structure, dependent on template. context : quote : What is love? attribution : Haddaway my_list : - 1 - 2 - 3 # Mapping from tag names to tag overrides. tags : error_tag : include : template_name : \"non-patterns/include.html\"","title":"YAML structure"},{"location":"reference/api/#templates","text":"","title":"Templates"},{"location":"reference/api/#pattern_library_rendered_pattern","text":"pattern_library_rendered_pattern is required in the template defined as PATTERN_BASE_TEMPLATE_NAME . This gets replaced by the rendered pattern\u2019s HTML when displaying patterns in the library. <body> {% block content %}{{ pattern_library_rendered_pattern }}{% endblock %} </body>","title":"pattern_library_rendered_pattern"},{"location":"reference/api/#settings","text":"See Getting started for more guided information.","title":"Settings"},{"location":"reference/api/#pattern_library","text":"All settings should be set as keys of the PATTERN_LIBRARY object. PATTERN_LIBRARY = { # [\u2026] }","title":"PATTERN_LIBRARY"},{"location":"reference/api/#sections","text":"SECTIONS controls the groups of templates that appear in the navigation. The keys are the group titles and the values are lists of template name prefixes that will be searched to populate the groups. The pattern library searches for templates both in DIRS directories for template engines, and in the templates subdirectory inside each installed application if using APP_DIRS . You can use this to create basic two-folder \"includes and pages\" hierarchies: PATTERN_LIBRARY = { \"SECTIONS\" : ( ( \"components\" , [ \"patterns/components\" ]), ( \"pages\" , [ \"patterns/pages\" ]), ), } Or more detailed structures following Atomic Design : PATTERN_LIBRARY = { \"SECTIONS\" : ( ( \"atoms\" , [ \"patterns/atoms\" ]), ( \"molecules\" , [ \"patterns/molecules\" ]), ( \"organisms\" , [ \"patterns/organisms\" ]), ( \"templates\" , [ \"patterns/templates\" ]), ( \"pages\" , [ \"patterns/pages\" ]), ), }","title":"SECTIONS"},{"location":"reference/api/#template_suffix","text":"Defaults to .html . Only set this if your templates use another file extension. PATTERN_LIBRARY = { \"TEMPLATE_SUFFIX\" : \".dj\" , }","title":"TEMPLATE_SUFFIX"},{"location":"reference/api/#pattern_base_template_name","text":"PATTERN_BASE_TEMPLATE_NAME is the template that fragments will be wrapped with. It should include any required CSS and JS, and output pattern_library_rendered_pattern from context. PATTERN_LIBRARY = { \"PATTERN_BASE_TEMPLATE_NAME\" : \"patterns/base.html\" , }","title":"PATTERN_BASE_TEMPLATE_NAME"},{"location":"reference/api/#base_template_names","text":"Any template in BASE_TEMPLATE_NAMES or any template that extends a template in BASE_TEMPLATE_NAMES is a \"page\" and will be rendered as-is without being wrapped. PATTERN_LIBRARY = { \"BASE_TEMPLATE_NAMES\" : [ \"patterns/base_page.html\" ], }","title":"BASE_TEMPLATE_NAMES"},{"location":"reference/api/#monkey_utils","text":"","title":"monkey_utils"},{"location":"reference/api/#override_tag","text":"This function tells the pattern library which Django tags to override, and optionally supports providing a default value. See Overriding template tags for more information. from pattern_library.monkey_utils import override_tag override_tag ( register , 'a_tag_name' , default_html = \"https://example.com/\" )","title":"override_tag"},{"location":"reference/api/#register_context_modifier","text":"This decorator makes it possible to override or create additional context data with Django / Python code, rather than being limited to YAML. It has to be called from within a pattern_contexts module, which can be at the root of any Django app. See Modifying template contexts with Python for more information. # myproject/core/pattern_contexts.py from pattern_library import register_context_modifier from myproject.core.forms import SearchForm , SignupForm @register_context_modifier def add_common_forms ( context , request ): if 'search_form' not in context : context [ \"search_form\" ] = SearchForm ()","title":"register_context_modifier"},{"location":"reference/api/#commands","text":"","title":"Commands"},{"location":"reference/api/#render_patterns","text":"Renders all django-pattern-library patterns to HTML files, in a directory structure. This can be useful for automated tests . Usage: # Render all patterns to the default directory. ./manage.py render_patterns # Render patterns without outputting files. ./manage.py render_patterns --dry-run # Render all patterns, with fragment patterns wrapped in the base template. ./manage.py render_patterns --wrap-fragments # Render patterns to a specific directory. ./manage.py render_patterns --output ./my/path/relative/to/cwd # Render patterns to stdout. ./manage.py render_patterns --dry-run --verbosity 2 # View all options ./manage.py render_patterns --help By default patterns will be saved in a dpl-rendered-patterns folder. Make sure to add this to your .gitignore and other ignore files, or customize the output directory with --output .","title":"render_patterns"},{"location":"reference/concepts/","text":"Concepts \u00b6 To understand how django-pattern-library works, the following concepts are important. Patterns \u00b6 Any template that is displayed by the pattern library is referred to as a pattern. Patterns are divided into two categories: fragments and pages. Fragments \u00b6 A fragment is a pattern whose markup does not include all of the resources (typically CSS and Javascript) for it to be displayed correctly on its own. This is typical for reusable component templates which depend on global stylesheets or Javascript bundles to render and behave correctly. To enable them to be correctly displayed in the pattern library, django-pattern-library will inject the rendered markup of fragments into the pattern base template specified by PATTERN_LIBRARY['PATTERN_BASE_TEMPLATE_NAME'] . This template should include references to any required static files. The rendered markup of fragments will be available in the pattern_library_rendered_pattern context variable (see the tests for an example ). Pages \u00b6 In contrast to fragments, pages are patterns that include everything they need to be displayed correctly in their markup. Pages are defined by PATTERN_LIBRARY['BASE_TEMPLATE_NAMES'] . Any template in that list \u2014 or that extends a template in that list \u2014 is considered a page and will be displayed as-is when rendered in the pattern library. It is common practice for page templates to extend the pattern base template to avoid duplicate references to stylesheets and Javascript bundles. Again, an example of this can be seen in the tests.","title":"Concepts"},{"location":"reference/concepts/#concepts","text":"To understand how django-pattern-library works, the following concepts are important.","title":"Concepts"},{"location":"reference/concepts/#patterns","text":"Any template that is displayed by the pattern library is referred to as a pattern. Patterns are divided into two categories: fragments and pages.","title":"Patterns"},{"location":"reference/concepts/#fragments","text":"A fragment is a pattern whose markup does not include all of the resources (typically CSS and Javascript) for it to be displayed correctly on its own. This is typical for reusable component templates which depend on global stylesheets or Javascript bundles to render and behave correctly. To enable them to be correctly displayed in the pattern library, django-pattern-library will inject the rendered markup of fragments into the pattern base template specified by PATTERN_LIBRARY['PATTERN_BASE_TEMPLATE_NAME'] . This template should include references to any required static files. The rendered markup of fragments will be available in the pattern_library_rendered_pattern context variable (see the tests for an example ).","title":"Fragments"},{"location":"reference/concepts/#pages","text":"In contrast to fragments, pages are patterns that include everything they need to be displayed correctly in their markup. Pages are defined by PATTERN_LIBRARY['BASE_TEMPLATE_NAMES'] . Any template in that list \u2014 or that extends a template in that list \u2014 is considered a page and will be displayed as-is when rendered in the pattern library. It is common practice for page templates to extend the pattern base template to avoid duplicate references to stylesheets and Javascript bundles. Again, an example of this can be seen in the tests.","title":"Pages"},{"location":"reference/known-issues/","text":"Known issues and limitations \u00b6 django-pattern-library has a few known limitations due to its design, which are worth knowing about when authoring templates or attempting to document them in the pattern library. No way to specify objects that have attributes and support iteration \u00b6 See #10 . It\u2019s impossible to mock the context when a variable needs to support iteration and attributes. Here is an example of this impossible case: {% for result in search_results %} {# [\u2026] #} {% if search_results.paginator.count %} Overriding filters is not supported \u00b6 See #114 . PRs welcome! Django form fields are not well supported \u00b6 See #113 . If a template contains {% for field in form %} or even {% if form %} , then it's easy enough to render in django-pattern-library so long as we force the form to be null in the YAML context, and are happy not to have the form. If the form is rendered explicitly by field names, then it requires a lot more work, which can quickly become too much of a maintenance burden \u2013 for example creating deeply nested structures for form fields: form : email : bound_field : field : widget : class : __name__ : char_field While this is in theory possible, it\u2019s not a very desirable prospect. Can\u2019t override context in a child template \u00b6 See #8 . If you have a some_page.html , some_page.yaml , and include_me.html , include_me.html , and some_page.html includes include_me.html . some_page.yaml with something like: context : page : pk : 1 title : \"my title\" and include_me.yaml with something like: context : page : title : \"Title from include\" Title from include will appear on both patterns. It's impossible to override single key in some_page.html No support for pattern variations \u00b6 See #87 . There is currently no support for trying out a single component with different variations in context or tag overrides. This can be worked around by creating pattern-library-only templates, see Multiple template variants Can\u2019t mock each use of a template tag with different attributes \u00b6 For example, with a template that uses the same tag many times like: {% load wagtailcore_tags %} {% for link in primarynav %} {% with children = link.value.page.get_children.live.public.in_menu %} <div class=\"primary-nav__item\"> {% include_block link with has_children = children.exists nav_type = \"primary-nav\" %} <ul class=\"sub-nav\"> <li class=\"sub-nav__item\"> {% include_block link with nav_type = \"sub-nav\" %} </li> {% for child in children.all %} <li class=\"sub-nav__item sub-nav__item--secondary\"> {% include_block link with page = child nav_type = \"sub-nav\" %} </li> {% endfor %} </ul> </div> {% endwith %} {% endfor %} This can\u2019t be mocked for all usage of include_block . Can\u2019t mock objects comparison by reference \u00b6 With instances of models, the following works fine in vanilla Django, due to item and page being the same object: {% if item == page %} This can\u2019t be mocked with the pattern library\u2019s context mocking support. As a workaround, you can switch equality checks to using literals: {% if item.id == page.id %}","title":"Known issues"},{"location":"reference/known-issues/#known-issues-and-limitations","text":"django-pattern-library has a few known limitations due to its design, which are worth knowing about when authoring templates or attempting to document them in the pattern library.","title":"Known issues and limitations"},{"location":"reference/known-issues/#no-way-to-specify-objects-that-have-attributes-and-support-iteration","text":"See #10 . It\u2019s impossible to mock the context when a variable needs to support iteration and attributes. Here is an example of this impossible case: {% for result in search_results %} {# [\u2026] #} {% if search_results.paginator.count %}","title":"No way to specify objects that have attributes and support iteration"},{"location":"reference/known-issues/#overriding-filters-is-not-supported","text":"See #114 . PRs welcome!","title":"Overriding filters is not supported"},{"location":"reference/known-issues/#django-form-fields-are-not-well-supported","text":"See #113 . If a template contains {% for field in form %} or even {% if form %} , then it's easy enough to render in django-pattern-library so long as we force the form to be null in the YAML context, and are happy not to have the form. If the form is rendered explicitly by field names, then it requires a lot more work, which can quickly become too much of a maintenance burden \u2013 for example creating deeply nested structures for form fields: form : email : bound_field : field : widget : class : __name__ : char_field While this is in theory possible, it\u2019s not a very desirable prospect.","title":"Django form fields are not well supported"},{"location":"reference/known-issues/#cant-override-context-in-a-child-template","text":"See #8 . If you have a some_page.html , some_page.yaml , and include_me.html , include_me.html , and some_page.html includes include_me.html . some_page.yaml with something like: context : page : pk : 1 title : \"my title\" and include_me.yaml with something like: context : page : title : \"Title from include\" Title from include will appear on both patterns. It's impossible to override single key in some_page.html","title":"Can\u2019t override context in a child template"},{"location":"reference/known-issues/#no-support-for-pattern-variations","text":"See #87 . There is currently no support for trying out a single component with different variations in context or tag overrides. This can be worked around by creating pattern-library-only templates, see Multiple template variants","title":"No support for pattern variations"},{"location":"reference/known-issues/#cant-mock-each-use-of-a-template-tag-with-different-attributes","text":"For example, with a template that uses the same tag many times like: {% load wagtailcore_tags %} {% for link in primarynav %} {% with children = link.value.page.get_children.live.public.in_menu %} <div class=\"primary-nav__item\"> {% include_block link with has_children = children.exists nav_type = \"primary-nav\" %} <ul class=\"sub-nav\"> <li class=\"sub-nav__item\"> {% include_block link with nav_type = \"sub-nav\" %} </li> {% for child in children.all %} <li class=\"sub-nav__item sub-nav__item--secondary\"> {% include_block link with page = child nav_type = \"sub-nav\" %} </li> {% endfor %} </ul> </div> {% endwith %} {% endfor %} This can\u2019t be mocked for all usage of include_block .","title":"Can\u2019t mock each use of a template tag with different attributes"},{"location":"reference/known-issues/#cant-mock-objects-comparison-by-reference","text":"With instances of models, the following works fine in vanilla Django, due to item and page being the same object: {% if item == page %} This can\u2019t be mocked with the pattern library\u2019s context mocking support. As a workaround, you can switch equality checks to using literals: {% if item.id == page.id %}","title":"Can\u2019t mock objects comparison by reference"},{"location":"reference/related-projects/","text":"Related projects \u00b6 Here are other projects that are similar to django-pattern-library, and may be relevant if you\u2019re looking to go further, or wanting to try out alternatives: storybook-django \u2013 attempting to bridge the gap between React and Django, by bringing django-pattern-library patterns into Storybook stories. django-reusable-components \u2013 Reusable UI components for Django, going further than template partials. Alternatives \u00b6 Storybook , and in particular Storybook for Server \u2013 Storybook integration with server-rendered UI components. Pattern Lab \u2013 PHP or Node pattern library, from which this project is heavily inspired. Astrum \u2013 Similar to Pattern Lab, Node based. rikki-patterns \u2013 Experimental Django-friendly pattern library generator, for Jinja2 and Nunjucks templates Pattern libraries based on Django \u00b6 Here are open-source projects that maintain pattern libraries for Django. With django-pattern-library : rca.ac.uk Department for Transport: Road Freight Survey - Alpha project Without django-pattern-library : Wagtail NHS.UK frontend consumerfinance.gov","title":"Related projects"},{"location":"reference/related-projects/#related-projects","text":"Here are other projects that are similar to django-pattern-library, and may be relevant if you\u2019re looking to go further, or wanting to try out alternatives: storybook-django \u2013 attempting to bridge the gap between React and Django, by bringing django-pattern-library patterns into Storybook stories. django-reusable-components \u2013 Reusable UI components for Django, going further than template partials.","title":"Related projects"},{"location":"reference/related-projects/#alternatives","text":"Storybook , and in particular Storybook for Server \u2013 Storybook integration with server-rendered UI components. Pattern Lab \u2013 PHP or Node pattern library, from which this project is heavily inspired. Astrum \u2013 Similar to Pattern Lab, Node based. rikki-patterns \u2013 Experimental Django-friendly pattern library generator, for Jinja2 and Nunjucks templates","title":"Alternatives"},{"location":"reference/related-projects/#pattern-libraries-based-on-django","text":"Here are open-source projects that maintain pattern libraries for Django. With django-pattern-library : rca.ac.uk Department for Transport: Road Freight Survey - Alpha project Without django-pattern-library : Wagtail NHS.UK frontend consumerfinance.gov","title":"Pattern libraries based on Django"}]}